<?xml version="1.0" encoding="utf-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.0.30 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC4627 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4627.xml">
<!ENTITY RFC7159 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7159.xml">
<!ENTITY RFC2119 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC5234 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5234.xml">
<!ENTITY SELF "[RFCXXXX]">
]>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>

<rfc ipr="pre5378Trust200902" docName="hjson-draft" category="std">

  <front>
    <title abbrev="Hjson">The Human JSON (Hjson) Configuration Format</title>

    <author initials="C." surname="Zangl" fullname="Christian Zangl">
      <organization></organization>
      <address>
        <email>laktak@cdak.net</email>
      </address>
    </author>

    <date year="2016" month="May"/>

    <area>Applications</area>
    <workgroup>none</workgroup>
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>Human JSON (Hjson) is a configuration file format based on the JavaScript Object Notation <xref target="RFC7159"/>. Its focus is to provide a reasonable alternative to plain JSON configs that are hard to edit and do not allow comments.</t>



    </abstract>


  </front>

  <middle>


<section anchor="intro" title="Introduction">

<t>Human JSON (Hjson) is a configuration file format. It is a superset of the JavaScript Object Notation <xref target="RFC7159"/>.</t>

<t>Hjson uses the same four primitive types (strings, numbers, booleans, and null) and two structured types (objects and arrays) as JSON.</t>

<t>A string is a sequence of zero or more Unicode characters <xref target="UNICODE"/>.
Note that this citation references the latest version of Unicode
rather than a specific release. It is not expected that future
changes in the UNICODE specification will impact the syntax of Hjson.</t>

<t>An object is an unordered collection of zero or more name/value
pairs, where a name is a string and a value is a string, number,
boolean, null, object, or array.</t>

<t>An array is an ordered sequence of zero or more values.</t>

<t>The terms “object” and “array” come from the conventions of
JavaScript.</t>

<t>Hjson’s design goals were</t>

<t><list style="symbols">
  <t>to improve readability and editability over JSON while keeping the familiar syntax intact</t>
  <t>to maintain backward compatibility, so that any valid JSON is valid Hjson</t>
  <t>to provide a reasonable alternative to plain JSON configs</t>
</list></t>

<section anchor="conventions-used-in-this-document" title="Conventions Used in This Document">

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”,
“SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this
document are to be interpreted as described in <xref target="RFC2119"/>.</t>

<t>The grammatical rules in this document are to be interpreted as described in <xref target="RFC5234"/> except where they are specifically marked as <xref target="SABNF"/>.</t>

<t>SABNF is used to express grammars that are not possible in ABNF, like the block-comment, and to define terminators, like ql-end, that allow us to exclude certain sequences. These constructs allow us to generate parsers and to verify the grammar against test cases. For the general understanding of the language they can be ignored.</t>

</section>
<section anchor="specifications-of-hjson" title="Specifications of Hjson">

<t>This document describes Hjson and registers the media type “application/hjson”.</t>

</section>
</section>
<section anchor="hjson-grammar" title="Hjson Grammar">

<t>A Hjson text is a sequence of tokens. The set of tokens includes seven structural characters, comments, strings, numbers, and three literal names.</t>

<t>A Hjson text is either a serialized value or a root object.</t>

<figure><artwork type="abnf"><![CDATA[
   Hjson-text = ws-c ( root-object / value ) ws-c
]]></artwork></figure>

<t>These are the seven structural characters:</t>

<figure><artwork type="abnf"><![CDATA[
   begin-array      = ws-c %x5B ws-c     ; [ left square bracket

   begin-object     = ws-c %x7B ws-c     ; { left curly bracket

   end-array        = ws-c %x5D ws-c     ; ] right square bracket

   end-object       = ws-c %x7D ws-c     ; } right curly bracket

   name-separator   = ws-c %x3A ws-c     ; : colon

   comma-separator  = ws-c %x2C ws-c     ; , comma

   lf-separator     = *( comment /
                        *(space / tab / cr) )
                      lf ws-c            ; Line feed or New line
]]></artwork></figure>

<t>Insignificant whitespace and comments are allowed before or after any of the first six structural characters.</t>

<figure><artwork type="abnf"><![CDATA[
   ws-c  = *( comment / ws )

   ws    = *( space / tab / lf / cr )

   space = %x20    ; Space
   tab   = %x09    ; Horizontal tab
   lf    = %x0A    ; Line feed or New line
   cr    = %x0D    ; Carriage return
]]></artwork></figure>

<t>Comments can be specified as line or block comments.</t>

<figure><artwork type="abnf"><![CDATA[
   comment = line-comment / block-comment

   line-comment  = ( %x23 /        ; # hash
                     %x2F.2F )     ; // slash + slash
                   *( tab / cr / %x20-10FFFF ) ; until lf

   block-comment = start-block-comment
                   *( !end-block-comment anychar )
                   end-block-comment

   start-block-comment = %x2F.2A   ; /* slash + star

   end-block-comment = %x2A.2F     ; */ star + slash

   anychar = tab / cr / lf / %x20-10FFFF

   ; SABNF: block-comment requies the use of the
   ;        ! operator to allow * and / in the text
   ;        while stopping at */
]]></artwork></figure>

</section>
<section anchor="values" title="Values">

<t>A Hjson value MUST be an object, array, number, or string, or one of
the following three literal names:</t>

<figure><artwork type="abnf"><![CDATA[
   false = %x66.61.6C.73.65   ; false

   null  = %x6E.75.6C.6C      ; null

   true  = %x74.72.75.65      ; true
]]></artwork></figure>

<t>The literal names MUST be lowercase. No other literal names are allowed.</t>

<figure><artwork type="abnf"><![CDATA[
   value = literal / object / array / number / string

   literal = ( false / null / true ) !literal-end

   literal-end =
            *( space / tab )
            ( %x21-22 / %x24-2B / %x2D-2E / %x30-5A /
              %x5C / %x5E-7A / %x7C / %x7E-10FFFF )
            ; exclude #/,[]{}

   ; SABNF: define literal-end to prevent matches
   ;        that are actually a ql-string
   ;        (like "true blue")
]]></artwork></figure>

</section>
<section anchor="value-separators" title="Value Separators">

<t>Values can be separated directly by a comma or indirectly by one or more linefeeds.</t>

<figure><artwork type="abnf"><![CDATA[
   value-separator = comma-separator / lf-separator
]]></artwork></figure>

<t>Note that while Hjson allows the use of lf as a separator, the cr character is generally ignored. This should not be an issue as all modern operating systems use either lf or cr+lf as their line terminator.</t>

</section>
<section anchor="objects" title="Objects">

<t>An object structure is represented as a pair of curly brackets surrounding zero or more name/value pairs (or members). A single colon comes after each name, separating the name from the value. A comma separates a value from the next name unless the value is followed by a linefeed, in which case the comma is optional. Trailing separators are allowed. The names within an object SHOULD be unique.</t>

<figure><artwork type="abnf"><![CDATA[
   object = begin-object
            *( member [value-separator] )
            end-object

   member = name name-separator value
]]></artwork></figure>

<t>If the Hjson text defines an object it does not have to include the braces at the root level:</t>

<figure><artwork type="abnf"><![CDATA[
   root-object =
            1*( member [value-separator] )
]]></artwork></figure>

<t>A name can be specified as a JSON string (with quotes) or as a name without quotes.</t>

<figure><artwork type="abnf"><![CDATA[
   name = json-string / keyname

   keyname =  1*non-control-char

   non-control-char = %x21-2B / %x2D-39 / %x3B-5A /
                      %x5C / %x5E-7A / %x7C / %x7E-10FFFF
      ; any non-control character (excludes ,:[]{} and ws)
]]></artwork></figure>

<t>For interoperability issues regarding the uniquness of names and object member ordering, see <xref target="RFC7159"/> Section 4.</t>

</section>
<section anchor="arrays" title="Arrays">

<t>An array structure is represented as square brackets surrounding zero or more values (or elements). Elements are separated by commas or linefeeds. Trailing commas are allowed.</t>

<figure><artwork type="abnf"><![CDATA[
   array =  begin-array
            *( value [value-separator] )
            end-array
]]></artwork></figure>

<t>There is no requirement that the values in an array be of the same type.</t>

</section>
<section anchor="numbers" title="Numbers">

<t>The representation of numbers is similar to that used in most
programming languages. A number is represented in base 10 using
decimal digits. It contains an integer component that may be
prefixed with an optional minus sign, which may be followed by a
fraction part and/or an exponent part. Leading zeros are not
allowed.</t>

<t>A fraction part is a decimal point followed by one or more digits.</t>

<t>An exponent part begins with the letter E in upper or lower case,
which may be followed by a plus or minus sign. The E and optional
sign are followed by one or more digits.</t>

<t>Numeric values that cannot be represented in the grammar below (such
as Infinity and NaN) are not permitted.</t>

<figure><artwork type="abnf"><![CDATA[
   number = [ minus ] int [ frac ] [ exp ] !num-end

   decimal-point = %x2E       ; .

   digit = %x30-39            ; 0-9

   digit1-9 = %x31-39         ; 1-9

   e = %x65 / %x45            ; e E

   exp = e [ minus / plus ] 1*digit

   frac = decimal-point 1*digit

   int = zero / ( digit1-9 *digit )

   minus = %x2D               ; -

   plus = %x2B                ; +

   zero = %x30                ; 0

   num-end =  *( space / tab )
              ( %x21-22 / %x24-2B / %x2D-2E / %x30-5A /
              %x5C / %x5E-7A / %x7C / %x7E-10FFFF )
              ; exclude #/,[]{}

   ; SABNF: define num-end to prevent matches
   ;        that are actually a ql-string
   ;        (like "1 minute")
]]></artwork></figure>

<t>For limits on the range and precision of numbers see <xref target="RFC7159"/> Section 6.</t>

</section>
<section anchor="strings" title="Strings">

<t>Hjson allows strings to be represented in three different formats.</t>

<figure><artwork type="abnf"><![CDATA[
   string = json-string / ml-string / ql-string
]]></artwork></figure>

<section anchor="json-strings" title="JSON Strings">

<t>The representation of JSON strings is similar to conventions used in the C
family of programming languages. A string begins and ends with
quotation marks. All Unicode characters may be placed within the
quotation marks, except for the characters that must be escaped:
quotation mark, reverse solidus, and the control characters (U+0000
through U+001F).</t>

<t>Any character may be escaped. If the character is in the Basic
Multilingual Plane (U+0000 through U+FFFF), then it may be
represented as a six-character sequence: a reverse solidus, followed
by the lowercase letter u, followed by four hexadecimal digits that
encode the character’s code point. The hexadecimal letters A though
F can be upper or lower case. So, for example, a string containing
only a single reverse solidus character may be represented as
“\u005C”.</t>

<t>Alternatively, there are two-character sequence escape
representations of some popular characters. So, for example, a
string containing only a single reverse solidus character may be
represented more compactly as “\”.</t>

<t>To escape an extended character that is not in the Basic Multilingual
Plane, the character is represented as a 12-character sequence,
encoding the UTF-16 surrogate pair. So, for example, a string
containing only the G clef character (U+1D11E) may be represented as
“\uD834\uDD1E”.</t>

<figure><artwork type="abnf"><![CDATA[
   json-string = quotation-mark *char quotation-mark

   char = unescaped /
       escape (
           %x22 /          ; "    quotation mark  U+0022
           %x5C /          ; \    reverse solidus U+005C
           %x2F /          ; /    solidus         U+002F
           %x62 /          ; b    backspace       U+0008
           %x66 /          ; f    form feed       U+000C
           %x6E /          ; n    line feed       U+000A
           %x72 /          ; r    carriage return U+000D
           %x74 /          ; t    tab             U+0009
           %x75 4hexdig )  ; uXXXX                U+XXXX

   hexdig = %x30-39 / "A" / "B" / "C" / "D" / "E" / "F"

   escape = %x5C              ; \

   quotation-mark = %x22      ; "

   unescaped = %x20-21 / %x23-5B / %x5D-10FFFF
]]></artwork></figure>

</section>
<section anchor="quoteless-strings" title="Quoteless Strings">

<t>Hjson allows strings to be represented only by their content without quotes. A quoteless string may contain any character except the control characters (U+0000 through U+001F) and excluding trailing whitespace. It ends at the first linefeed. Strings are taken as is without escapes.</t>

<figure><artwork type="abnf"><![CDATA[
   ql-string = non-control-char
               *( !ql-end ql-char )

   ql-end    = *( space / tab / cr ) lf

   ql-char   = space / tab / %x21-10FFFF

   ; SABNF: define ql-end to exclude trailing
   ;        whitespace from the ql-string
]]></artwork></figure>

<t>Valid Hjson tokens cannot start a quoteless string. That means that, for example, { will still start an object and a valid number will be parsed as such. Likewise a ] would end an array while it will create a quoteless string inside an object.</t>

<t>Not allowing escapes inside the quoteless string allows you to specify HTML fragments, regular expressions or Windows style paths as-is, keeping them readable.</t>

</section>
<section anchor="multiline-strings" title="Multiline Strings">

<t>A multiline string begins and ends with three single quotes.</t>

<figure><artwork type="abnf"><![CDATA[
   ml-string =
      ml-seq
      *( !ml-seq ( ml-char / ml-ignore ) )
      ml-seq

   ml-seq = "'''"

   ml-char = space / tab / lf / %x21-10FFFF

   ml-ignore = cr

   ; SABNF: ml-string requies the use of the
   ;        ! operator to allow ' in the text
   ;        while stopping at '''
]]></artwork></figure>

<t>The carrige return character is generally ignored to make the parser platform independent.</t>

<t>Whitespace handling cannot be expressed in the ABNF grammar and is thus defined as text:</t>

<t><list style="symbols">
  <t>Whitespace on the first line is ignored.</t>
  <t>The first three single quotes define the head. On the following lines all whitespace up to the column of the first single quote is ignored.</t>
  <t>All other whitespace is assumed to be part of the string.</t>
  <t>The last newline is ignored to allow for better formatting.</t>
</list></t>

</section>
</section>
<section anchor="string-and-character-issues" title="String and Character Issues">

<section anchor="character-encoding" title="Character Encoding">

<t>Hjson text SHALL be encoded in UTF-8. Since Hjson parsers can read JSON they may be able to read texts in other encodings (such as UTF-16 and UTF-32). Hjson texts that are encoded in UTF-8 are interoperable in the sense that they will be read successfully by the maximum number of implementations.</t>

<t>Implementations MUST NOT add a byte order mark to the beginning of a Hjson text. In the interests of interoperability, implementations that parse Hjson texts MAY ignore the presence of a byte order mark rather than treating it as an error.</t>

</section>
<section anchor="unicode-characters" title="Unicode Characters">

<t>When all the strings represented in a Hjson text are composed entirely
of Unicode characters <xref target="UNICODE"/> (however escaped), then that Hjson
text is interoperable in the sense that all software implementations
that parse it will agree on the contents of names and of string
values in objects and arrays.</t>

<t>However, the ABNF in this specification allows member names and
string values to contain bit sequences that cannot encode Unicode
characters; for example, “\uDEAD” (a single unpaired UTF-16
surrogate). Instances of this have been observed, for example, when
a library truncates a UTF-16 string without checking whether the
truncation split a surrogate pair. The behavior of software that
receives Hjson texts containing such values is unpredictable; for
example, implementations might return different values for the length
of a string value or even suffer fatal runtime exceptions.</t>

</section>
<section anchor="string-comparison" title="String Comparison">

<t>Software implementations are typically required to test names of
object members for equality. Implementations that transform the
textual representation into sequences of Unicode code units and then
perform the comparison numerically, code unit by code unit, are
interoperable in the sense that implementations will agree in all
cases on equality or inequality of two strings. For example,
implementations that compare strings with escaped characters
unconverted may incorrectly find that “a\b” and “a\u005Cb” are not
equal.</t>

</section>
</section>
<section anchor="parsers" title="Parsers">

<t>A Hjson parser transforms a Hjson text into another representation. A
Hjson parser MUST accept all texts that conform to the Hjson grammar.
A Hjson parser MAY accept non-Hjson forms or extensions.</t>

<t>An implementation may set limits on the size of texts that it
accepts. An implementation may set limits on the maximum depth of
nesting. An implementation may set limits on the range and precision
of numbers. An implementation may set limits on the length and
character contents of strings.</t>

</section>
<section anchor="generators" title="Generators">

<t>A Hjson generator produces Hjson text. The resulting text MUST
strictly conform to the Hjson grammar.</t>

</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>The MIME media type for Hjson text is application/hjson.</t>

<t>Type name:  application</t>

<t>Subtype name:  hjson</t>

<t>Required parameters:  n/a</t>

<t>Optional parameters:  n/a</t>

<t>Encoding considerations:  binary</t>

<t>Security considerations:  See TODO, Section 13.</t>

<t>Interoperability considerations:  Described in TODO</t>

<t>Published specification:  TODO</t>

<t>Applications that use this media type:
   Hjson has been used to provide configuration data for applications written in all of these programming languages: C#, Go, Java, JavaScript, PHP and Python</t>

<t>Additional information:
   Magic number(s): n/a
   File extension(s): .hjson
   Macintosh file type code(s): TEXT</t>

<t>Person &amp; email address to contact for further information:
   IESG
   <eref target="mailto:iesg@ietf.org">iesg@ietf.org</eref></t>

<t>Intended usage:  COMMON</t>

<t>Restrictions on usage:  none</t>

<t>Author:
   Christian Zangl
   <eref target="mailto:laktak@cdak.net">laktak@cdak.net</eref></t>

<t>Change controller:
   IESG
   <eref target="mailto:iesg@ietf.org">iesg@ietf.org</eref></t>

<t>Note:  No “charset” parameter is defined for this registration.
   Adding one really has no effect on compliant recipients.</t>

</section>
<section anchor="security-considerations" title="Security Considerations">

<t>Unlike JSON, Hjson is not a subset of Javascript and cannot be parsed using “eval()”.</t>

</section>
<section anchor="examples" title="Examples">

<t>This is a Hjson object:</t>

<figure><artwork><![CDATA[
   {
     TODO
   }
]]></artwork></figure>

</section>
<section anchor="contributors" title="Contributors">

<t>This document is based on <xref target="RFC4627"/> and <xref target="RFC7159"/> which were written by Douglas Crockford and Tim Bray. This document was constructed by extending it with the elements of the Hjson syntax.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>

&RFC4627;
&RFC7159;
&RFC2119;
&RFC5234;
<reference anchor="UNICODE" target="http://www.unicode.org/versions/latest/">
  <front>
    <title>The Unicode Standard</title>
    <author >
      <organization>The Unicode Consortium</organization>
    </author>
    <date year="n.d."/>
  </front>
</reference>
<reference anchor="SABNF" target="https://github.com/ldthomas/apg-js2/blob/2fa136e00e5932d70ed1bd4786101c87afa8ca2e/SABNF.md">
  <front>
    <title>Superset Augmented Backus-Naur Form</title>
    <author initials="L.D." surname="Thomas" fullname="Lowell D. Thomas">
      <organization></organization>
    </author>
    <date year="n.d."/>
  </front>
  <seriesInfo name="version" value="2.2.1"/>
</reference>


    </references>




  </back>
</rfc>

